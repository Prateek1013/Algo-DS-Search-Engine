C2. Good Numbers (hard version)time limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputThe only difference between easy and hard versions is the maximum value of nn.You are given a positive integer number nn. You really love good numbers so you want to find the smallest good number greater than or equal to nn.The positive integer is called good if it can be represented as a sum of distinct powers of 33 (i.e. no duplicates of powers of 33 are allowed).For example:  3030 is a good number: 30=33+3130=33+31,  11 is a good number: 1=301=30,  1212 is a good number: 12=32+3112=32+31,  but 22 is not a good number: you can't represent it as a sum of distinct powers of 33 (2=30+302=30+30),  1919 is not a good number: you can't represent it as a sum of distinct powers of 33 (for example, the representations 19=32+32+30=32+31+31+31+3019=32+32+30=32+31+31+31+30 are invalid),  2020 is also not a good number: you can't represent it as a sum of distinct powers of 33 (for example, the representation 20=32+32+30+3020=32+32+30+30 is invalid). Note, that there exist other representations of 1919 and 2020 as sums of powers of 33 but none of them consists of distinct powers of 33.For the given positive integer nn find such smallest mm (n≤mn≤m) that mm is a good number.You have to answer qq independent queries.InputThe first line of the input contains one integer qq (1≤q≤5001≤q≤500) — the number of queries. Then qq queries follow.The only line of the query contains one integer nn (1≤n≤10181≤n≤1018).OutputFor each query, print such smallest integer mm (where n≤mn≤m) that mm is a good number.ExampleInputCopy8
1
2
6
13
14
3620
10000
1000000000000000000
OutputCopy1
3
9
13
27
6561
19683
1350851717672992089
