C. Books Queriestime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputYou have got a shelf and want to put some books on it.You are given qq queries of three types:  L idid — put a book having index idid on the shelf to the left from the leftmost existing book;  R idid — put a book having index idid on the shelf to the right from the rightmost existing book;  ? idid — calculate the minimum number of books you need to pop from the left or from the right in such a way that the book with index idid will be leftmost or rightmost. You can assume that the first book you will put can have any position (it does not matter) and queries of type 33 are always valid (it is guaranteed that the book in each such query is already placed). You can also assume that you don't put the same book on the shelf twice, so idids don't repeat in queries of first two types.Your problem is to answer all the queries of type 33 in order they appear in the input.Note that after answering the query of type 33 all the books remain on the shelf and the relative order of books does not change.If you are Python programmer, consider using PyPy instead of Python when you submit your code.InputThe first line of the input contains one integer qq (1≤q≤2⋅1051≤q≤2⋅105) — the number of queries.Then qq lines follow. The ii-th line contains the ii-th query in format as in the problem statement. It is guaranteed that queries are always valid (for query type 33, it is guaranteed that the book in each such query is already placed, and for other types, it is guaranteed that the book was not placed before).It is guaranteed that there is at least one query of type 33 in the input.In each query the constraint 1≤id≤2⋅1051≤id≤2⋅105 is met.OutputPrint answers to queries of the type 33 in order they appear in the input.ExamplesInputCopy8L 1R 2R 3? 2L 4? 1L 5? 1OutputCopy112InputCopy10L 100R 100000R 123L 101? 123L 10R 115? 100R 110? 115OutputCopy021NoteLet's take a look at the first example and let's consider queries:   The shelf will look like [1][1];  The shelf will look like [1,2][1,2];  The shelf will look like [1,2,3][1,2,3];  The shelf looks like [1,2,3][1,2,3] so the answer is 11;  The shelf will look like [4,1,2,3][4,1,2,3];  The shelf looks like [4,1,2,3][4,1,2,3] so the answer is 11;  The shelf will look like [5,4,1,2,3][5,4,1,2,3];  The shelf looks like [5,4,1,2,3][5,4,1,2,3] so the answer is 22. Let's take a look at the second example and let's consider queries:   The shelf will look like [100][100];  The shelf will look like [100,100000][100,100000];  The shelf will look like [100,100000,123][100,100000,123];  The shelf will look like [101,100,100000,123][101,100,100000,123];  The shelf looks like [101,100,100000,123][101,100,100000,123] so the answer is 00;  The shelf will look like [10,101,100,100000,123][10,101,100,100000,123];  The shelf will look like [10,101,100,100000,123,115][10,101,100,100000,123,115];  The shelf looks like [10,101,100,100000,123,115][10,101,100,100000,123,115] so the answer is 22;  The shelf will look like [10,101,100,100000,123,115,110][10,101,100,100000,123,115,110];  The shelf looks like [10,101,100,100000,123,115,110][10,101,100,100000,123,115,110] so the answer is 11. 